import { ticketMock } from "tests/mocks/ticket/index";
import { create } from "v1/api/ticket/create/helpers/create.service";
import { TicketTypeEnum } from "v1/enum/ticket-type";

describe("create service", () => {
	describe("successful", () => {
		const validCode = "f1w3f";
		const validName = "generic";
		const validDescription = "tenso";
		const validType = TicketTypeEnum.PERCENTAGE;
		const validDiscountValue = 50;
		const validExpirationDate = new Date();

		it("should return a ticket", async () => {
			let result: any;

			const doc = ticketMock.doc({
				code: validCode,
				name: validName,
				description: validDescription,
				type: validType,
				discountValue: validDiscountValue,
				expirationDate: validExpirationDate,
			});

			ticketMock.repository.save.mockResolvedValue(doc);

			try {
				result = await create(
					{
						ticketRepository: ticketMock.repository,
					},
					{
						code: validCode,
						name: validName,
						description: validDescription,
						type: validType,
						discountValue: validDiscountValue,
						expirationDate: validExpirationDate,
					},
				);
			} catch (err: any) {
				result = err;
			}

			expect(result).toStrictEqual(doc);
		});

		it("should return a ticket with an autogenerated code", async () => {
			let result: any;

			const doc = ticketMock.doc({
				code: validCode,
				name: validName,
				description: validDescription,
				type: validType,
				discountValue: validDiscountValue,
				expirationDate: validExpirationDate,
			});

			ticketMock.repository.save.mockResolvedValue(doc);

			try {
				result = await create(
					{
						ticketRepository: ticketMock.repository,
					},
					{
						name: validName,
						description: validDescription,
						type: validType,
						discountValue: validDiscountValue,
						expirationDate: validExpirationDate,
					},
				);
			} catch (err: any) {
				result = err;
			}

			const expectedTicket = ticketMock.repository.save.mock.calls[0][0].code;

			expect(ticketMock.repository.save).toBeCalledWith({
				name: validName,
				description: validDescription,
				type: validType,
				discountValue: validDiscountValue,
				expirationDate: validExpirationDate,
				code: expectedTicket,
			});

			expect(typeof result.code).toBe("string");
		});
	});
});
